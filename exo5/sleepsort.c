// https://stackoverflow.com/questions/55873277/creating-n-child-process-in-c-using-fork/55873350

// Superimer les headers inutils
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdnoreturn.h>
#include <string.h>
#include <unistd.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <inttypes.h>
#include <stdbool.h>
#include <sys/stat.h>
#include <time.h>
#include <utime.h>
#include <sys/wait.h>
#include <getopt.h>

// Verification des appels de primitives systemes
#define CHECK(v)                     \
    do {                             \
        if ((v) == -1) raler(1, #v); \
    } while (0)

// Fonction raler amelioree
noreturn void raler(int syserr, const char* fmt, ...);

void computeRandNumList(uint8_t n, uint8_t nMax, uint8_t *numbersList);

void parseStrToNumList(int nChar, char* charList[], uint8_t *numbersList);

bool parseCmdLineArg(int argc, char *argv[], char *format, int64_t *n, int64_t *nMax);

int main(int argc, char *argv[]){
    int c;
    bool errFlag = false;
    extern char *optarg;
    extern int optind;

    char *nCh, nMaxCh;          // n, et nmax en string
    bool r = false;             // Indique si l'option r a ete donnee ou pas
    bool m = false;             // Indique si l'option m
    int64_t n, nMax;            // 64 bits pour detecter les grosses valeurs
    char *inputList;            // Liste des nombres au format texte
    uint8_t *numbersList;       // La liste des nombres a trier

//-----------------------------

    while ((c = getopt(argc, argv, "r:m:")) != -1){
        switch (c){
        case 'r':
            r = true;
            // nCh = optarg;
            // char d = 
            n = atoi(optarg);
            // if (n <= 0 || n > 255)
            //     raler (0, "Debordement de limite ou conversion impossible");
            // COnvertir n en uint 8
            break;
        case 'm':
            m = true;
            // nMaxCh = optarg;
            nMax = atoi(optarg);
            // if (nMax <= 0 || nMax > 255)
            //     raler (0, "Debordement de limite ou conversion impossible");
            break;
        default:
            raler(0, "Argument inconnu");
            break;
        }
    } 


//-----------------------------

    // bool parse = parseCmdLineArg(argc, argv, "r:m:", &n, &nMax);

    if (r == true){
        // n = atoi(nCh);
        if (n <= 0 || n > 255)
            raler (0, "Debordement de limite ou conversion impossible");
        numbersList = malloc(n);
        if (numbersList == NULL)
            raler(1, "Erreur d'allocation");
        if (m == false){
            computeRandNumList(n, n, numbersList);
        }
        else{    // m == true
            // nMax = atoi(nMaxCh);
            if (nMax <= 0 || nMax > 255)
                raler (0, "Debordement de limite ou conversion impossible");
            computeRandNumList(n, nMax, numbersList);
        }
    } else if (r == false && m == true)
        raler (0, "Fournissez le n");
    else{ // r == false && m == false   // Les nombres ont ete fournis
        n = argc - 1; 
        numbersList = malloc(n);
        if (numbersList == NULL)
            raler(1, "Erreur d'allocation");
        parseStrToNumList(n, argv, numbersList);
    }

    // Juste pour tester
    for (uint8_t i = 0; i < n; i++)
        printf ("%d\t", numbersList[i]);
    printf ("\n");
    


    pid_t pid; 
    int raison;
    bool isChild = false;
    uint8_t localValue = 0;
    uint64_t sum = 0; 
    // Juste pour tester
    for (uint8_t i = 0; i < n; i++)
        switch(pid = fork()){
            case -1:
                raler (0, "Erreur de fork");
                break;
            case 0:
                isChild = true;
                localValue = numbersList[i];
                // printf("%d   %d\n", localPid, localValue);
                // CHECK(usleep(numbersList[i]*100000));
                // printf("%d\n", numbersList[i]);
                // exit(numbersList[i]);
                break;
            default:;
                // localPid = pid;
                // wait(&raison);
                // sum += WEXITSTATUS(raison);
                // sum += numbersList[i];
                // printf("Sum = %ld\n", sum);
                break;
        }

    // printf("%d   %d\n", localPid, localValue);

    // switch(isChild){
        if (isChild){
            printf("%d   %d\n", getpid(), localValue);
            // CHECK(usleep(localValue*100000));
            // printf("%d\n", localValue);
            exit(localValue);
            // break;
        }else{
            // exit(1);
            wait(&raison);
            sum += WEXITSTATUS(raison);
    }


    if (!isChild)    
        printf("Sum = %ld\n", sum);

    // if (pid != 0){
    //     sum += numbersList[i];
    //     printf("%ld\n", sum);
    // }


    // for (uint8_t i = 0; i < n; i++)
    //     printf ("%d\n", numbersList[i]);









    return 0;

}

// bool parseCmdLineArg(int argc, char *argv[], char *format, int64_t *n, int64_t *nMax){
//     int c;
//     bool r = false, m = false;
//     // if (strcmp(format, "r"))
//     while ((c = getopt(argc, argv, format)) != -1){
//         switch (c){
//         case 'r':
//             r = true;
//             *n = atoi(optarg);
//             break;
//         case 'm':
//             m = true;
//             *nMax = atoi(optarg);
//             break;
//         default:
//             raler(0, "Argument inconnu");
//             break;
//         }
//     }
//     return (r || r&&m) && (optind == argc); 
// }

void computeRandNumList(uint8_t n, uint8_t nMax, uint8_t *numbersList){
    for (uint8_t i = 0; i < n; i++)
        numbersList[i] = rand()%nMax;
}

void parseStrToNumList(int nChar, char* charList[], uint8_t *numbersList){
    int temp;
    for (uint8_t i = 0; i < nChar; i++){
        temp = atoi(charList[i+1]);
        if (temp <= 0 || temp > 255)
            raler(0, "Debordement de limite ou conversion impossible");
        numbersList[i] = temp;
    }
}

noreturn void raler(int syserr, const char* fmt, ...) {
    va_list ap;
    va_start(ap, fmt);
    vfprintf(stderr, fmt, ap);
    fprintf(stderr, "\n");
    va_end(ap);
    if (syserr) perror("");
    exit(1);
}